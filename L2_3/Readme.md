Программа выведет nil и false. 

В первой строке создается переменная err, которая является типом error - встроенным в язык go интерфейсом, имеющим единственный метод .Error(), который возвращает string. Сам интерфейс состоит из двух полей - структуру tab, где содержится указатель на конкретный тип данных, который удовлетворяет требованиям этого интерфейса и таблица методов, где для каждого метода интерфейса хранится указатель на конкретную реализацию, а также data - ссылка на сам объект. В нашем случае из функции Foo возвращается объект типа интерфейс error, содержащий в себе тип *os.PathError (у которого есть реализация метода Error() string) и nil ссылку на объект PathError.

Во второй строке вызывается fmt.Println(err). Внутри Println содержится логика, позволяющая корректно обработать nil объект, поэтому выведется nil. Если бы мы вызвали напрямую err.Error(), получили бы панику.

В третьей строке вызывается fmt.Println(err == nil), где будут сравниваться поля err. В нашем случае err имеет свой тип, поэтому поле tab не nil и результат сравнения будет false. Для true необходимо, чтобы все поля err были nil.

Отличие пустого интерфейса в том, что он не содержит в себе методы, которые необходимо реализовать. Поэтому любой объект будет удовлетворять пустому интерфейсу. Это применяется например в функции Println, которая должна принимать любой объект и корректно его обрабатывать. Например для всех не базовых типов, если объект удовлетворяет интерфейсу fmt.Stringer, будет выполнен метод String(), если удовлетворяет интерфейсу error, будет выполнен метод Error(), в остальных случаях будут выведены все поля структуры.